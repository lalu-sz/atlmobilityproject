<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">
    <meta name="generator" content="">
    <title>Infrastructure & Expierence</title>


    <!-- Bootstrap core CSS -->
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet">
    <!-- Leaflet CSS -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" rel="stylesheet">
    <!-- Leaflet Routing Machine CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.css" />

    <style>
        /* Cover template styles */
        .inner.cover {
            width: 100%;
            height: 100%;
            padding-top: 2%;
            padding-left: 2%;
            padding-right: 2%;
            background-color: rgba(142, 155, 185, 0.8);
        }

        body {
            margin: 0;
            padding: 0;
            display: flex;
            height: 100%;
            background-image: url('participantIcons/fivepoints.jpg');
            background-size: cover;
            background-position: center;
            position: relative;
        }

        body::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(rgba(181, 198, 236, 0.7), rgba(26, 35, 75, 0.7));
            z-index: 1;
            /* Ensure the overlay is behind the content */
        }

        .container-fluid {
            width: 100%;
            display: flex;
            height: 100vh;
            z-index: 2;
        }

        /* Fullscreen styles */
        .container-fluid:fullscreen {
            width: 100vw;
            height: 100vh;
            display: flex;
        }

        .container-fluid:-webkit-full-screen {
            width: 100vw;
            height: 100vh;
            display: flex;
        }

        .container-fluid:-moz-full-screen {
            width: 100vw;
            height: 100vh;
            display: flex;
        }

        .container-fluid:-ms-fullscreen {
            width: 100vw;
            height: 100vh;
            display: flex;
        }

        /* Side Panel */
        #side-pane {
            display: flex;
            flex-direction: column;
            /* Stack children vertically */
            width: 300px;
            /* Fixed width for the side panel */
            background-color: #e8eefa9c;
            /* Light background color */
            padding: 20px;
            /* Add some padding */
            box-shadow: -2px 0 5px rgba(0, 0, 0, 0.1);
            /* Shadow on the left side */
            overflow-y: auto;
            /* Enable scrolling if content overflows */
        }

        /* Button Row */
        #button-row {
            display: flex;
            justify-content: space-between;
            /* Distribute space evenly between icons */
            align-items: center;
            width: 100%;
            margin-bottom: 20px;
        }

        /* Icon Buttons */
        .icon-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 0;
            flex: 1;
            /* Distribute available space equally */
            display: flex;
            flex-direction: column;
            /* Stack image and text */
            justify-content: center;
            align-items: center;
            /* Center content */
            text-align: center;
            /* Ensure text is centered */
        }

        .icon-btn span {
            font-family: Arial, sans-serif;
            font-weight: lighter;
            text-align: center;
            color: #333;
            /* Adjust text color */
        }

        /* Icon Images */
        .icon-btn img {
            width: 70px;
            /* Set a fixed size for icons */
            height: 80px;
            max-width: 100%;
            /* Ensure icons don't overflow */
            max-height: 100%;
        }

        .icon-btn:hover {
            background-color: rgba(113, 177, 35, 0.3);
            /* Light background on hover */
            border-radius: 5px;
            /* Rounded corners */
        }

        .icon-btn img {
            transition: transform 0.2s ease;
            /* Smooth hover animation */
        }

        .icon-btn:hover img {
            transform: scale(1.1);
            /* Slightly enlarge the icon on hover */
        }

        .next-btn {
            display: block;
            margin: 15px auto;
            padding: 8px 15px;
            background-color: #1a2127;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        .next-btn:hover {
            background-color: #92997c;
        }

        /* Content Divs */
        .content-div {
            display: none;
            /* Hide all content divs by default */
            padding: 10px;
            margin-bottom: 20px;
            /* Add some space below each content div */
            text-align: left;
        }

        .container-fluid {
            text-align: left;
        }

        .content-div.active {
            display: block;
            /* Show the active content div */
        }

        /* Additional Text */
        #additional-text {
            margin-bottom: 20px;
            /* Add some space below the text */
        }

        /* Layer Controls */
        #layer-controls {
            margin-bottom: 20px;
            /* Add some space below the controls */
        }

        /* Center Fullscreen Button */
        #fullscreen-btn {
            display: block;
            /* Ensures it behaves like a block element */
            width: 60%;
            /* Adjust width as needed */
            background-color: rgba(25, 36, 83, 0.8);
            border-radius: 10px;
            margin: 0 auto 30px auto;
            /* Center horizontally */
            text-align: center;
            /* Ensures text inside the button is centered */
        }


        #map {
            background: #b4bd9b;
            flex: 1;
            height: 100vh;
            /* Fixed height */
            width: 100%;
            /* Full width of its container */
            margin: 0 auto;
            z-index: 1;
            position: relative;
        }

        .nav-pills .nav-link {
            color: #333;
            /* Default text color */
            font-weight: bold;
            /* Bold text */
            margin: 0 10px;
            /* Add spacing between links */
            border-radius: 10px;
            /* Rounded corners for pills */
            transition: background-color 0.3s ease, color 0.3s ease;
            /* Smooth transition */
        }

        .nav-pills .nav-link.active {
            color: #080101;
            /* Active link text color */
            background-color: rgba(145, 165, 196, 0.9);
            /* Active link background color */
        }

        header,
        footer {
            position: relative;
            /* Ensure header and footer are positioned */
            z-index: 3;
            /* Ensure they are above the map */
        }

        /* Add some padding to the main content */
        main {
            padding: 20px 0;
            z-index: 2;
        }

        /* Style for the custom layers control container */
        .custom-layers-control {
            background-color: #bac2d4;
            /* Light gray background */
            color: #333;
            /* Dark text color */
            padding: 10px;
            border-radius: 5px;
            text-align: left;
        }


        /* Additional styles for layer labels */
        .custom-layers-control .leaflet-control-layers-label {
            font-weight: bold;
            color: #555;

        }

        h3.mb-0 {
            font-size: 40px;
        }

        @media (min-width: 768px) {}
    </style>

</head>

<body class="text-center">
    <div class="cover-container d-flex w-100 h-100 p-3 mx-auto flex-column">
        <header class="d-flex justify-content-between align-items-center py-3 mb-4">
            <!-- Title -->
            <h3 class="mb-0">the atlanta mobility project</h3>

            <!-- Navigation Pills -->
            <ul class="nav nav-pills mb-0">
                <li class="nav-item">
                    <a class="nav-link" href="index.html" id="home-link">home</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="stories.html" id="stories-link">stories</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="about.html" id="about-link">about</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="author.html" id="author-link">author</a>
                </li>
            </ul>
        </header>
        <!-- Main Content -->
        <main role="main" class="inner cover">
            <p class="lead">This project seeks to understand racialized mobility differentials (inequities in movement
                or capacity for movement) in Atlanta, Georgia.
                Experiences and strategies of mobility are documented through participatory sketch mapping of
                research participants' daily routes, emotions, and experiences produced during as they move.
            </p>

            <p class="lead">
                In context with Atlanta's deeply conflicted history of development, racialized mobility differentials
                and experiences of movement across segregated space and racialized
                infrastructure will be put into analytical conversation through geospatial visualization.</p>

            <a href="#" id="fullscreen-btn" class="btn btn-lg btn-secondary">explore map</a>

            <audio id="background-music" src="mixkit-urban-ambient-sound-2465.mp3" loop></audio>

            <!-- Map & Side Pane -->
            <div class="container-fluid">
                <!-- Side Pane -->
                <div id="side-pane">
                    <h2>select a story</h2>

                    <p>Select a person to explore Narratives and Expierences of Mobility.
                    </p>


                    <!-- Button Row -->
                    <div id="button-row">
                        <button id="btn-1" class="icon-btn">
                            <img src="participantIcons/black_fem.png" alt="Icon 1">
                            <span>Debra</span>
                        </button>
                        <button id="btn-2" class="icon-btn">
                            <img src="participantIcons/white_fem.png" alt="Icon 2">
                            <span>Emily</span>
                        </button>

                    </div>

                    <!-- Content Divs -->
                    <div id="debra-1" class="content-div">
                        <h3>Debra's Story</h3>
                        <p><b>Age:</b> 56 </p>
                        <p><b>Tenure:</b> Atlanta Native </p>
                        <p>Debra has lived in southwest Atlanta her whole life and she emphasises how important
                            indpendence is for her. However Debra never learned to drive, she hated the high speed
                            nature of driving in Atlanta and laments about how some drivers just act like they don't
                            care about others. So while many of her peers might base thier independence on car
                            ownership, Debra refuses to secure independence this way. Additionally, As an older woman
                            who travels alone often she doesnt feel safe
                            in Ubers or Lyfts. She also stresses that ride sharing apps are too expensive for her
                            limited income shes afforded by working part-time at a local bank. </p>
                        <p> While Debra exclusively uses MARTA buses, and trains if the distance is longer, she says she
                            isnt depedent on MARTA, rather:</p>
                        <h3>
                            "I depend on God to get me where I need to go"
                        </h3>
                        <button class="next-btn" data-next="debra-2">Next</button>

                    </div>
                    <div id="debra-2" class="content-div" style="display: none;">
                        <p> In the city that is famously known to "pray for transit" (Karner and Duckworth, 2018), Debra
                            centers her relationship to God during her day-to-day actvities and movement.</p>

                        <p> However, these prayers can often go unanswered as it did for Debra on a sweltering summer
                            afternoon in late May of 2024.</p>
                        <p>Overall, Debra does find it relatively easy to move throughout the city</p>
                        <button class="next-btn" data-next="debra-3">Next</button>

                    </div>
                    <div id="debra-3" class="content-div" style="display: none;">

                        <p>It seemed like a normal afternoon for Debra. As she usally does, she signalled the driver to
                            left her off at her stop, a mere few 100 feet from her home. As the bus doors came smashing
                            open, Debra began to step off the bus. To her suprise, the bus hadn't been stopped correct,
                            and the driver never lower the bus to the ground as protocal requires. Miss Debra fell of
                            the
                            bus, hitting the hard pavement, with only her wrist to break her fall. </p>

                        <p>In the aftermath of her fall, Debra in shock worried that she broke her face, was assited off
                            the ground by the bus driver and a fellow bus passenger. Immediatly after, she noted she was
                            fine besides a few scratches on her face, but the next day her wrist was still in pain, so
                            after a trip to Urgent Care it was confirmed Debra sprained her wrist. At the time of the
                            interview (August 2024), Debra was still healing from the incident and praying she didnt
                            need surgery as one of her doctors suggested.</p>

                        <button class="next-btn" data-next="debra-1">Restart</button>


                    </div>

                    <div id="emily-1" class="content-div" style="display: none;">
                        <h3>Emily's Story</h3>
                        <p><b>Age:</b> 22 </p>
                        <p><b>Tenure:</b> 2 Years </p>
                        <p>Emily is young college student living and working in downtown Atlanta.
                            Originally from a small rural town in South Georgia, Emily and her partner are both working
                            towards thier Bachelor degrees and working part-time to support themselves as independently
                            as possible.

                            Emily's background is standard to the middle-class rural-small town upbringing, with her
                            parents gifting her an older model car when she was 16 which she was determined to drive
                            until it couldnt drive anymore.
                        </p>

                        <pv>Sadly for Emily, that time came a lot sooner than expect.</pv>
                        <button class="next-btn" data-next="emily-2">Next</button>

                    </div>
                    <div id="emily-2" class="content-div" style="display: none;">
                        <h3>Emily's Story</h3>
                        <p>One late night while driving home from work, Emily was driving on Dekalb Avenue, a nutorious
                            arterial that runs through and parrallel to Edgewood, a historically Black business
                            district. Despreate to get home and to avoid the aggressive driver in front of her who was
                            repeatly break-chcking her, she attempted to switch into a turning lane early. Dekalb
                            avenue, a very bumpy ride, is notoruus for deep and recorrung potholes. As Emily switched
                            lanes she felt a rather large bump which to her suprise was not a pothole but infact a low
                            grade pedestrian median nearby a MARTA station. "ole betsy" was totaled.
                        </p>

                        <p>"The police tried to blame me, but the median has no signage; it's only a walkway and the
                            concrete pads. I had almost hit it probably 3 times before in broad daylight as well.
                            Afterwards they installed pedestrian crossing signs. Those also keep getting knocked over.
                            Every once and a while I’ll pass the same spot and I’ll see pieces of cars scattered across
                            the roadway and it makes me feel less alone." </p>

                        <button class="next-btn" data-next="emily-3">Next</button>
                    </div>
                    <div id="emily-3" class="content-div" style="display: none;">
                        <h3>Emily's Story</h3>
                        <p>
                            Emily described the situation as a financial nightmare, and while her family was moderately
                            affluent, even they were in no position to help Emily. With no other solution, Emily took
                            out a student loan to cover the loss of her car and purchase a new one. Emily needed a car.
                            Both her and her partner's jobs werent accessible by MARTA, and thier apartment was a 20
                            mintue walk from the closes train station.

                            She had to buy another car soon after, because Emily operates on a extremely restricted
                            income, she would only afford older, used cars which just didnt seem like they could hold up
                            against these mean Atlanta streets.
                        </p>
                        <button class="next-btn" data-next="emily-1">Restart</button>
                    </div>

                    <p>Use the Legend icon to toggle additional layers on/off.</p>

                    <div id="layer-controls">
                        <p class="lead">
                            <a href="index.html" id="fullscreen-btn" class="btn btn-lg btn-secondary">Return to
                                Homepage</a>
                        </p>
                        <label for="volume-slider">Volume:</label>
                        <input type="range" id="volume-slider" min="0" max="1" step="0.1" value="1">

                    </div>
                </div>

                <!-- Map Container -->
                <div id="map"></div>
            </div>
            <!-- Footer -->
            <footer class="mastfoot mt-auto">
                <br>
                <p>Map created by Laurel Sparks | Published May, 2025 | <a href="about.html#data">metadata</a>
                </p>


            </footer>
        </main>
    </div>

    <!-- Add Bootstrap -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz"
        crossorigin="anonymous"></script>
    <!-- Leaflet JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
    <script async defer
        src="https://maps.googleapis.com/maps/api/js?key=AIzaSyD8eMkO29SDNWF1XQEGE7ejGjjFx2ZUdrU&libraries=geometry"></script>

    <script type="module">
        import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";
        // Add footer date

        let points = null; // Global variable to store points (needed for routing)
        let routeLayers = {};
        let allRoutes = [];
        let directionsService;


        // basically recreating URL with variables
        const a = {
            data: {},
            domain: {
                unit: "block%20group",
                state: ['13'], // ["*"], 
                county: ['089', '121'],
                tract: ["*"],
                block_group: ["*"],
                data: "2019/acs/acs5",
            },
            variables: [{
                name: "totalPopulation",
                label: "Total Population",
                var: "B02001_001E",
            },
            {
                name: "blackPopulation",
                label: "Black Population",
                var: "B02001_003E",
            },

            ],
            vars: {
                totalV: "totalPopulation",
                blackV: "blackPopulation"
            },
            geojson: {
                counties: "data/fultonDekalbBG.json",
            },
        };
        // Set global variables for header, map container, and footer
        const header = document.querySelector("header");
        const mapContainer = document.querySelector("#map");
        const footer = document.querySelector("footer");
        const locate = document.querySelector("#geolocate-ui");

        // Call the main functions to test local storage and setup the map
        testLocalStorage()

        // Check for localStorage
        function testLocalStorage() {
            // try to write and remove an item
            try {
                localStorage.setItem('test', 'test');
                localStorage.removeItem('test');
                console.log(localStorage);
                setLocalStorage()
            } catch (e) {
                console.log('Local storage not available:', e);
                // Will need to fork the code to handle this case :(
            }
        }

        // Check for localStorage and set up caching
        function setLocalStorage() {
            // If our app data is not in localStorage, clear local storage.
            // This is a way to clear out old data while we develop the app.
            if (!localStorage.getItem("myApp")) {
                localStorage.clear();
            } else {
                // If we do have the app data, check if it is expired.
                // If it's older than 6 minutes, clear it.
                const myApp = JSON.parse(localStorage.getItem("myApp"));
                if (checkExpired(myApp.timestamp, 0.1)) {
                    localStorage.clear();
                }
            }
            // Create an object to store in localStorage.
            const data = {
                info: "Storing information in localStorage",
            }
            // Store the data in localStorage, which will add a timestamp.
            try {
                storeData("myApp", data);
            } catch (e) {
                console.warn('Failed to setup storage:', e);
                // Hmm... what to do here?
            }
        }

        // Check for expiration of data in localStorage
        // using timestamp od stored data and desired duration in hours
        function checkExpired(timestamp, hours) {
            const duration = hours * (60 * 60 * 1000); // set duration in hours
            // Milliseconds since 1970 (when rock n roll really started)
            const now = Date.now();
            // Check if data is older than duration
            if (now - timestamp > duration) {
                return true; // Data is expired
            } else {
                return false; // Data is still fresh
            }
        }
        // Retrieve data from localStorage using key and check for expiration
        function retrieveData(key) {
            const cached = localStorage.getItem(key);
            // If no data, return null. End function.
            if (!cached) return null;

            // Destructure properties to new variables
            const { timestamp, data } = JSON.parse(cached);

            // Check if data is expired, e.g., older than 6 minutes
            if (checkExpired(timestamp, 0.1)) {
                // Remove expired data from localStorage
                // which will force a refetch next time.
                localStorage.removeItem(key);
            }
            // Return the data to where function is called
            return data;
        }
        // Store data in localStorage with key name
        function storeData(key, data) {
            // Build an object with timestamp and data
            const cacheObject = {
                timestamp: Date.now(),
                data: data
            };
            // Store the object in localStorage with try/catch
            try {
                localStorage.setItem(key, JSON.stringify(cacheObject));
            } catch (e) {
                console.warn('Failed to cache data:', e);
                // Hmm... what to do here?
                // Over time, localStorage can fill up.
                // Maybe clear and refetch?
            }
        }
        // Fetch GeoJSON data with caching
        // using a key and URL
        async function fetchJSON(key, url) {
            // try/catch block to handle errors
            try {
                // Check cache first
                const cachedData = retrieveData(key);
                // If cachedData not null...
                if (cachedData) {
                    console.log('Using cached data');
                    return cachedData;
                }
                // Fetch fresh data if no cache
                console.log('Fetching fresh data');
                // await for fetch to resolve and parse JSON
                const response = await fetch(url);
                if (!response.ok) throw new Error('Network response was not ok, dig?');
                const data = await response.json();

                // Store the data in localStorage
                storeData(key, data);

                // Return the data to where function is called
                return data;
            } catch (error) {
                console.error('Error fetching data:', error);
                // Hmm... what to do here?
                throw error;
            }
        }

        async function getLocalData() {
            try {
                const zcta = await d3.json("data/fdZCTA.geojson");
                const points = await d3.json("data/allPointsMerged.geojson");
                const homeLoc = await d3.json("data/dislocated_HLs.geojson");
                const places = await d3.json("data/gaPlaces.geojson");
                const roads = await d3.json("data/atlRoadsHoe.geojson");

                return { zcta, homeLoc, points, places, roads };
            } catch (error) {
                console.error("ERROR!", error);
                return null;
            }
        }
        let map; // Declare map at the top so it's accessible everywhere

        async function setupMap(zcta, homeLoc, points, places) {
            let options = {
                center: [33.748997, -84.387985],
                zoom: 13,
                scrollWheelZoom: false
            };

            // Retrieve cached map options
            if (retrieveData('mapOptions')) {
                console.log('Using cached map options');
                options = retrieveData('mapOptions');
            }

            // Initialize the map and assign it to the global variable `map`
            map = L.map('map').setView(options.center, options.zoom);

            //Style URL: mapbox://styles/lalu-sz-/cltc7cx6n03d001p65ybi1sjz   
            // Add Mapbox's tile layer using your custom style URL
            L.tileLayer('https://api.mapbox.com/styles/v1/lalu-sz-/cltc7cx6n03d001p65ybi1sjz/tiles/{z}/{x}/{y}?access_token=pk.eyJ1IjoibGFsdS1zei0iLCJhIjoiY2xzdjM4cm90MmJ6bDJsbWpqejJneDhzNCJ9.bja8-N3mGgqGqJXjzu8lrA', {
                attribution: 'Map data &copy; <a href="https://www.mapbox.com/about/maps/">Mapbox</a> contributors',
                maxZoom: 18,
                access_token: 'pk.eyJ1IjoibGFsdS1zei0iLCJhIjoiY2xzdjM4cm90MmJ6bDJsbWpqejJneDhzNCJ9.bja8-N3mGgqGqJXjzu8lrA'  // Replace with your Mapbox access token
            }).addTo(map);

            directionsService = new google.maps.DirectionsService();

            // Store map options in localStorage when map pans or zooms
            map.on('moveend', function () {
                const data = {
                    center: map.getCenter(),
                    zoom: map.getZoom()
                };
                storeData('mapOptions', data);
            });

            console.log("Map initialized:", map);
            return map;
        }

        // Define the function to get the census data.
        async function getCensus() {
            // Create an empty GeoJSON to hold the features
            const acsData = {
                "type": "FeatureCollection",
                "name": "Urban Atlanta Counties",
                "crs": { "type": "name", "properties": { "name": "urn:ogc:def:crs:OGC:1.3:CRS84" } },
                "features": []
            };
            // map method returns new array of variables
            // by looping through a.variables array and returning the var property.
            // join method convert the array into a string with items separated by commas.
            const variables = a.variables.map((v) => v.var).join(",");
            // Create the URL for the Census API.
            const url = `https://api.census.gov/data/${a.domain.data}?get=NAME,${variables}&for=${a.domain.unit}:*&in=state:${a.domain.state}&in=county:${a.domain.county}&in=tract:${a.domain.tract}`;
            const urlDekalb = `https://api.census.gov/data/${a.domain.data}?get=NAME,${variables}&for=${a.domain.unit}:*&in=state:${a.domain.state}`;
            //console.log(url); //looks good

            // Create an array of promises from two fetch requests.
            // The first fetch request gets the census data and assigns it to the variable censusResponse.
            // The second fetch request gets the county geometry data and assigns it to the variable geometryResponse.
            const [censusResponse, geometryResponse] = await Promise.all([
                fetch(url).then((r) => r.json()),
                fetch(a.geojson.counties).then((r) => r.json()),
            ]);
            // The function will pause here until all promises are resolved.

            // Make shorthand variable names.
            // Remove header row (index value 0) from the census data (an array of arrays).
            // slice method starts at second item and selects to the end of the array.
            const censusData = censusResponse.slice(1);
            const countyGeom = geometryResponse;

            //console.log(countyGeom); //TRACTCE: 010304 & GEOID: 131210103041...no ready join field
            //need to create join field 
            countyGeom.features.forEach((feature) => {

                feature.properties.joinField = feature.properties.TRACTCE + feature.properties.BLKGRPCE;
            });

            // Loop through the census data.
            for (const census of censusData) {
                // Slice off last two elements, concatenate, and assign to countyFips.
                // The -2 index is the second to last element in the array.
                const countyFips = census.slice(-2).join("");
                //console.log(countyFips); //7 (tract and block)

                // Find the geometry that matches the countyFips via GEOID.
                // find method returns the first element in array that matches the condition
                // and returns the entire object.
                const match = countyGeom.features.find(g => g.properties.joinField === countyFips);

                // If there is a match, add the census data to it. 
                if (match) {
                    //console.log(match); //looks good
                    // Create a new object in the properties object of the match object.
                    match.properties.census = {};

                    // Loop through the a.variables array.
                    // Use the name property and index to assign the census data.
                    // Builds an object with the name property as the key and the census data as the value.
                    a.variables.forEach(({ name }, i) => {
                        // console.log(name, i, census[i], census[i + 1]);
                        // Offset by 1 because the first element is the county name.
                        match.properties.census[name] = census[i + 1];
                    });

                    // Add the match object to the acsData object.
                    // This will contain all counties with census data.
                    acsData.features.push(match);
                }
            }
            console.log('json', acsData);
            return acsData;
        }// end getCensus

        getLocalData().then((dataUpload) => {
            if (!dataUpload) {
                console.error("Failed to load local data. Check file paths or JSON syntax.");
                return;
            }

            let { zcta, homeLoc, points, places, roads } = dataUpload;
            points = dataUpload.points; // Global access to points

            if (!points || !points.features) {
                console.error("Points data is missing or invalid.");
                return;
            }

            // Wait for the map to be ready before calling nextContent
            setupMap(zcta, homeLoc, points, places, roads).then((initializedMap) => {
                map = initializedMap;  // Ensure map is assigned globally
                createRoutes(points, map);
                getCensus().then((acsData) => {
                    drawMap(zcta, homeLoc, points, places, roads, map, acsData);
                    setupEventListeners(map);
                }).catch(error => {
                    console.error("Failed to fetch census data:", error);
                });
            }).catch(error => {
                console.error("Failed to set up the map:", error);
            });
        });

        // Function to create routes for each participant
        function createRoutes(points, map) {
            const groupedRoutes = {};
            const participantSet = new Set();

            points.features.forEach(feature => {
                const participantId = feature.properties.layer;
                const coords = {
                    lat: feature.geometry.coordinates[1],
                    lng: feature.geometry.coordinates[0]
                };

                if (!participantId) return;
                participantSet.add(participantId);

                if (!groupedRoutes[participantId]) {
                    groupedRoutes[participantId] = [];
                }
                groupedRoutes[participantId].push(coords);
            });

            // Process routes for each participant
            Object.keys(groupedRoutes).forEach(participantId => {
                let routeLines = drawFullyConnectedRoutes(groupedRoutes[participantId], participantId, map);
                routeLayers[participantId] = routeLines;
                routeLines.forEach(routeLine => {
                    allRoutes.push({ routeLine, participantId });
                });
            });

            console.log("Routes created successfully.");
        }

        // Function to draw fully connected routes
        function drawFullyConnectedRoutes(points, participantId, map) {
            if (!map) {
                console.error("Map is not defined!");
                return [];
            }

            if (!points || points.length < 2) return [];

            let lines = [];

            for (let i = 0; i < points.length; i++) {
                for (let j = i + 1; j < points.length; j++) {
                    if (points[i] && points[j]) {
                        const polyline = L.polyline([[points[i].lat, points[i].lng], [points[j].lat, points[j].lng]], {
                            color: "#f5f9e8",
                            weight: 4,
                            opacity: 0.3
                        });

                        polyline.addTo(map);
                        lines.push(polyline);
                    }
                }
            }

            return lines;
        }

        // Function to highlight participant routes
        function highlightRoutes(points, map) {
            if (!points || !points.features || points.features.length === 0) {
                console.error("No points data available for highlighting routes.");
                return;
            }

        }

        // Define the content steps and their corresponding map coordinates
        const contentLocations = {
            "debra-1": [33.66666, -84.39528],  // Example coordinates
            "debra-2": [33.68058, -84.42904],
            "debra-3": [33.753, -84.383],
            "emily-1": [33.75036492066822, -84.37557763552553],
            "emily-2": [33.78995, -84.37259],
            "emily-3": [33.74957, -84.39103],
        };
        window.nextContent = function (currentId, nextId) {
            console.log("Navigating from:", currentId, "to:", nextId);

            let currentDiv = document.getElementById(currentId);
            let nextDiv = document.getElementById(nextId);

            if (currentDiv && nextDiv) {
                currentDiv.style.display = "none"; // Hide current page
                nextDiv.style.display = "block"; // Show next page
            } else {
                console.error("Invalid navigation:", currentId, "→", nextId);
                return;
            }

            // Ensure map is initialized before calling setView()
            if (map && contentLocations[nextId]) {
                console.log("Moving map to:", contentLocations[nextId]);
                map.setView(contentLocations[nextId], 15); // Adjust zoom as needed
            } else {
                console.warn("No map instance or coordinates for", nextId);
            }
        };


        // Display GeoJSON
        function drawMap(zcta, homeLoc, points, places, roads, map, acsData) {
            // Create routes using the points data
            highlightRoutes(points, map);

            // Create custom panes with specific zIndex values
            map.createPane('suburbsPane');
            map.getPane('suburbsPane').style.zIndex = 200; // Lowest zIndex

            map.createPane('roadsPane');
            map.getPane('roadsPane').style.zIndex = 300;

            map.createPane('demographicsPane');
            map.getPane('demographicsPane').style.zIndex = 200;

            map.createPane('atlantaPane');
            map.getPane('atlantaPane').style.zIndex = 400;

            map.createPane('homesPane');
            map.getPane('homesPane').style.zIndex = 500;

            map.createPane('pointsPane');
            map.getPane('pointsPane').style.zIndex = 600; // Highest zIndex

            //census data first
            const color = d3.scaleQuantile()
                .domain([0.0, 1.0])
                .range(["#f9f6f6", "#cfb0b0", "#4f3030", "#170909"]);
            color.domain(acsData.features.map((d) => {
                return (d.properties.census[a.vars.blackV] / d.properties.census[a.vars.totalV]);
            }
            ));

            const demographics = L.geoJson(acsData, {
                pane: 'demographicsPane', // Assign to demographicsPane
                style: function (feature) {
                    const rate = (feature.properties.census[a.vars.blackV] / feature.properties.census[a.vars.totalV]);
                    return {
                        fillColor: color(rate),
                        weight: 0.25,
                        opacity: 1,
                        color: color(rate),
                        fillOpacity: 1,
                    };
                },
                onEachFeature: function (feature, layer) {
                    layer.bindTooltip(
                        `Community: ${feature.properties.TRACTCE}-${feature.properties.BLKGRPCE}: <br>
black pop: ~ ${(
                            (feature.properties.census[a.vars.blackV] / feature.properties.census[a.vars.totalV]) *
                            100
                        ).toFixed(1)}% <br>
white pop: ~ ${(
                            (1 - feature.properties.census[a.vars.blackV] / feature.properties.census[a.vars.totalV]) *
                            100
                        ).toFixed(1)}%`
                    );
                },
            })

            // Define the SVG icon for home location
            const iconUrl = "mapbox-maki-8.2.0-0-g6ab50f3/mapbox-maki-6ab50f3/icons/home.svg";
            const svgIcon = L.divIcon({
                html: `<img src="${iconUrl}" alt="Home Icon" width="32" height="32" />`, // Use an <img> tag to load the external SVG
                iconSize: [32, 32],
                iconAnchor: [16, 32],
                popupAnchor: [0, -32],
                className: 'custom-icon' // Apply the CSS class
            });

            // Create a Leaflet GeoJSON layer with style and popup
            const homes = L.geoJSON(homeLoc, { //change symbol
                pointToLayer: (feature, latlng) => {
                    return L.marker(latlng, {
                        icon: svgIcon
                    });
                },
                onEachFeature: (feature, layer) => {
                    if (feature.properties) {
                        const alias = (feature.properties.aliasName);
                        layer.bindPopup(
                            `<h3>${alias}'s neighborhood</h3>
`
                        );
                    }
                }
            }).addTo(map);

            // Define a color scale for the points
            const pointsScale = d3.scaleOrdinal()
                .domain(['Home Location', 'Grocery', 'Recreation', 'Workplace', 'Family', 'Religious', 'Education', 'Social', 'School',
                    'Enjoyment', 'Family', 'Health', 'Community Engagement'])
                .range(d3.schemeTableau10);

            // Empty layer group for buffers
            const bufferLayer = L.layerGroup().addTo(map);

            // Dictionary to store buffers by mode
            const buffersByMode = {
                driving: [],
                walking: [],
                MARTA: []
            };
            const pointsLayer = L.geoJSON(points, {
                pane: 'pointsPane', // Assign to pointsPane
                pointToLayer: (feature, latlng) => {
                    let pointColor = pointsScale(feature.properties.description);

                    // Create a circle marker
                    let marker = L.circleMarker(latlng, {
                        radius: 5, // Adjust size as needed
                        fillColor: pointColor,
                        color: pointColor,
                        weight: 1,
                        fillOpacity: 1
                    });

                    marker.addTo(map); // Directly add to the map
                }
            });

            const atlhoe = L.geoJSON(places, {
                pane: 'atlantaPane', // Assign to atlantaPane
                onEachFeature: (feature, layer) => {
                    if (feature.properties.NAME === "Atlanta") {
                        layer.setStyle({
                            color: '#efab00',
                            fillOpacity: 0,
                            weight: 4,
                            dashArray: '2,6',
                        });
                    }
                    else {
                        layer.setStyle({
                            fillOpacity: 0,
                            weight: 0,
                            interactive: false
                        });
                    }

                }
            }).addTo(map); //using Leaflet


            const roadSys = L.geoJSON(roads, {
                pane: 'roadsPane', // Assign to roadsPane
                onEachFeature: (feature, layer) => {
                    if (feature.properties.MTFCC === "S1100") { // Secondary
                        layer.setStyle({
                            color: '#98191f',
                            weight: 6
                        });
                    } else {
                        layer.setStyle({
                            color: '#efa9ae',
                            weight: 1,
                            interactive: false
                        });
                    }
                }
            }).addTo(map);

            var extraLayers = {

            }
            var participantData = {
                "Racial Demographics": demographics,
                "City Outline": atlhoe,
                "Participant Locations": pointsLayer,
                "Particpant Neigborhoods": homes,

            }

            L.Control.Layers.Custom = L.Control.Layers.extend({
                onAdd: function (map) {
                    var container = L.Control.Layers.prototype.onAdd.call(this, map);
                    L.DomUtil.addClass(container, 'custom-layer-control');

                    // Create legend inside layer control
                    var legendContainer = L.DomUtil.create("div", "legend-container", container);

                    // Define categories from the scale (should match `pointsScale.domain()`)
                    let categories = ['Home Location', 'Grocery', 'Recreation', 'Workplace', 'Family',
                        'Religious', 'Education', 'Social', 'School', 'Enjoyment',
                        'Health', 'Community Engagement'];

                    let legendHTML = `<strong>Types</strong><br>`;

                    // Generate legend HTML dynamically based on categories
                    categories.forEach(category => {
                        let color = pointsScale(category); // Get corresponding color
                        legendHTML += `<i style="background:${color}; width: 15px; height: 15px; display: inline-block; margin-right: 5px;"></i> ${category}<br>`;
                    });

                    legendContainer.innerHTML = legendHTML;

                    return container;
                }
            });

            // Add the custom layer control with the embedded legend
            var customLayersControl = new L.Control.Layers.Custom(extraLayers, participantData, { collapsed: false }).addTo(map);


            // Check for locations stored by user in localStorage
            // if locations exist, draw them on the map
            if (retrieveData('locations')) {
                const allLocations = retrieveData('locations')
                console.log(allLocations)
                drawLocations(map, homes, allLocations)
            }
        }
        function setupEventListeners(map) {
            const participants = {
                "btn-1": { contentId: "debra-1", participantId: "p6" },
                "btn-2": { contentId: "emily-1", participantId: "p2" },

            };

            Object.keys(participants).forEach(buttonId => {
                document.getElementById(buttonId).addEventListener("click", function () {
                    const { contentId, participantId } = participants[buttonId];

                    switchContent(contentId);
                    highlightParticipantRoutes(participantId, map);
                });
            });
        }

        // Function to switch content in the sidebar
        function switchContent(contentId) {
            console.log("Switching content to:", contentId);

            // Hide all content-divs
            document.querySelectorAll('.content-div').forEach(div => {
                div.style.display = 'none';
            });

            // Show the selected content
            let selectedContent = document.getElementById(contentId);
            if (selectedContent) {
                selectedContent.style.display = 'block';
            } else {
                console.error("Content ID not found:", contentId);
            }
        }

        document.querySelectorAll(".next-btn").forEach(button => {
            button.addEventListener("click", function () {
                let currentDiv = this.parentElement.id; // Get current div ID
                let nextDivId = this.dataset.next; // Get the 'data-next' value

                if (nextDivId) {
                    nextContent(currentDiv, nextDivId);
                } else {
                    console.error("No 'data-next' attribute found on this button");
                }
            });
        });


        function highlightParticipantRoutes(selectedParticipantId, map) {
            console.log("Highlighting route for participant:", selectedParticipantId);

            // Convert selected ID to lowercase for case-insensitive comparison
            const normalizedSelectedId = selectedParticipantId.toLowerCase();

            console.log("All Routes:", allRoutes);

            // Reset all routes to default
            allRoutes.forEach(({ routeLine }) => {
                routeLine.setStyle({ color: "#f5f9e8", weight: 4, opacity: 0.3 });
            });

            // Highlight only the selected participant’s routes
            allRoutes.forEach(({ routeLine, participantId }) => {
                const normalizedRouteId = participantId.toLowerCase(); // Convert each stored ID to lowercase

                console.log(`Checking route: ${normalizedRouteId} === ${normalizedSelectedId}`);

                if (normalizedRouteId === normalizedSelectedId) {
                    routeLine.setStyle({ color: "yellow", weight: 6, opacity: 1 });
                    routeLine.bringToFront();
                }
            });

            //map updates
            map.invalidateSize();
        }

        document.querySelectorAll(".next-btn").forEach(button => {
            button.addEventListener("click", function () {
                let currentDiv = this.parentElement.id; // Get current div ID
                let nextDivId = this.dataset.next; // Get the 'data-next' value

                if (nextDivId) {
                    nextContent(currentDiv, nextDivId);
                } else {
                    console.error("No 'data-next' attribute found on this button");
                }
            });
        });

        document.addEventListener("DOMContentLoaded", function () {
            const fullscreenBtn = document.getElementById('fullscreen-btn');
            const container = document.querySelector('.container-fluid');
            const musicElement = document.getElementById('background-music');
            const volumeSlider = document.getElementById("volume-slider");

            // Set the initial volume
            musicElement.volume = volumeSlider.value;

            // Update volume when slider moves
            volumeSlider.addEventListener("input", function () {
                musicElement.volume = this.value;
            });

            fullscreenBtn.addEventListener('click', function (event) {
                event.preventDefault();

                if (!document.fullscreenElement) {
                    // Enter fullscreen
                    if (container.requestFullscreen) {
                        container.requestFullscreen();
                    } else if (container.mozRequestFullScreen) {
                        container.mozRequestFullScreen();
                    } else if (container.webkitRequestFullscreen) {
                        container.webkitRequestFullscreen();
                    } else if (container.msRequestFullscreen) {
                        container.msRequestFullscreen();
                    }

                    // Play music when entering fullscreen
                    if (musicElement) {
                        musicElement.play();
                    }
                } else {
                    // Exit fullscreen
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    } else if (document.mozCancelFullScreen) {
                        document.mozCancelFullScreen();
                    } else if (document.webkitExitFullscreen) {
                        document.webkitExitFullscreen();
                    } else if (document.msExitFullscreen) {
                        document.msExitFullscreen();
                    }

                    // Pause music when exiting fullscreen
                    if (musicElement) {
                        musicElement.pause();
                    }
                }
            });
        });


        // Get all navigation links
        const navLinks = document.querySelectorAll('.nav-link');

        // Add click event listeners to each link
        navLinks.forEach(link => {
            link.addEventListener('click', function (event) {
                // Prevent default link behavior (optional)
                event.preventDefault();

                // Remove the 'active' class from all links
                navLinks.forEach(link => link.classList.remove('active'));

                // Add the 'active' class to the clicked link
                this.classList.add('active');

                // Optional: Navigate to the link's href
                window.location.href = this.href;
            });
        });
        // Get the current page URL
        const currentPage = window.location.href;

        // Loop through each link and check if it matches the current page
        navLinks.forEach(link => {
            if (link.href === currentPage) {
                link.classList.add('active');
            }
        });

    </script>
</body>

</html>