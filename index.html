<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">
    <meta name="generator" content="">
    <title>Infrastructure & Expierence</title>


    <!-- Bootstrap core CSS -->
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet">
    <!-- Leaflet CSS -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" rel="stylesheet">
    <!-- Leaflet Routing Machine CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.css" />

    <style>
        /* Cover template styles */
        .inner.cover {
            width: 100%;
            height: 100%;
            padding-top: 2%;
            padding-left: 2%;
            padding-right: 2%;
            background-color: rgba(250, 232, 249, 0.7);
        }

        body {
            margin: 0;
            padding: 0;
            display: flex;
            height: 100%;
            background-image: url('participantIcons/fivepoints.jpg');
            background-size: cover;
            background-position: center;
            position: relative;
        }

        body::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(rgba(246, 186, 242, 0.7), rgba(179, 58, 179, 0.7));
            z-index: 1;
            /* Ensure the overlay is behind the content */
        }

        .container-fluid {
            width: 100%;
            display: flex;
            height: 100vh;
            z-index: 2;
        }

        /* Fullscreen styles */
        .container-fluid:fullscreen {
            width: 100vw;
            height: 100vh;
            display: flex;
        }

        .container-fluid:-webkit-full-screen {
            width: 100vw;
            height: 100vh;
            display: flex;
        }

        .container-fluid:-moz-full-screen {
            width: 100vw;
            height: 100vh;
            display: flex;
        }

        .container-fluid:-ms-fullscreen {
            width: 100vw;
            height: 100vh;
            display: flex;
        }

        /* Side Panel */
        #side-pane {
            display: flex;
            flex-direction: column;
            /* Stack children vertically */
            width: 300px;
            /* Fixed width for the side panel */
            background-color: #f5fae8;
            /* Light background color */
            padding: 20px;
            /* Add some padding */
            box-shadow: -2px 0 5px rgba(0, 0, 0, 0.1);
            /* Shadow on the left side */
            overflow-y: auto;
            /* Enable scrolling if content overflows */
        }

        /* Button Row */
        #button-row {
            display: flex;
            justify-content: space-between;
            /* Distribute space evenly between icons */
            align-items: center;
            /* Center icons vertically */
            margin-bottom: 20px;
            /* Add some space below the button row */
        }

        /* Icon Buttons */
        .icon-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 0;
            /* Remove padding to ensure even spacing */
            flex: 1;
            /* Distribute available space equally */
            display: flex;
            justify-content: center;
            /* Center icons horizontally */
            align-items: center;
            /* Center icons vertically */
        }

        /* Icon Images */
        .icon-btn img {
            width: 60px;
            /* Set a fixed size for icons */
            height: 60px;
            max-width: 100%;
            /* Ensure icons don't overflow */
            max-height: 100%;
        }

        .icon-btn:hover {
            background-color: rgba(113, 177, 35, 0.3);
            /* Light background on hover */
            border-radius: 5px;
            /* Rounded corners */
        }

        .icon-btn img {
            transition: transform 0.2s ease;
            /* Smooth hover animation */
        }

        .icon-btn:hover img {
            transform: scale(1.1);
            /* Slightly enlarge the icon on hover */
        }

        /* Content Divs */
        .content-div {
            display: none;
            /* Hide all content divs by default */
            padding: 10px;
            border: 1px solid #ccc;
            margin-bottom: 20px;
            /* Add some space below each content div */
        }

        .content-div.active {
            display: block;
            /* Show the active content div */
        }

        /* Additional Text */
        #additional-text {
            margin-bottom: 20px;
            /* Add some space below the text */
        }

        /* Layer Controls */
        #layer-controls {
            margin-bottom: 20px;
            /* Add some space below the controls */
        }

        /* Fullscreen Button */
        #fullscreen-btn {
            width: 50%;
            background-color: rgba(179, 58, 179, 0.8);
            /* Make the button full width */
            margin-bottom: 30px;
            /* Add some space below the button */
            text-align: center;
        }

        #map {
            background: #2d2f31;
            flex: 1;
            height: 100vh;
            /* Fixed height */
            width: 100%;
            /* Full width of its container */
            margin: 0 auto;
            z-index: 1;
            position: relative;
        }

        .nav-pills .nav-link {
            color: #333;
            /* Default text color */
            font-weight: bold;
            /* Bold text */
            margin: 0 10px;
            /* Add spacing between links */
            border-radius: 20px;
            /* Rounded corners for pills */
            transition: background-color 0.3s ease, color 0.3s ease;
            /* Smooth transition */
        }

        .nav-pills .nav-link.active {
            color: #fff;
            /* Active link text color */
            background-color: rgba(179, 58, 179, 0.9);
            /* Active link background color */
        }

        header,
        footer {
            position: relative;
            /* Ensure header and footer are positioned */
            z-index: 3;
            /* Ensure they are above the map */
        }

        /* Add some padding to the main content */
        main {
            padding: 20px 0;
            z-index: 2;
        }

        /* The spinner container that centers the item. */
        .spinner-container {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            width: 100%;
            position: absolute;
            /* Position the spinner absolutely within the map */
            top: 0;
            left: 0;
            background: rgba(0, 0, 0, 0.5);
            /* Optional: Add a semi-transparent background */
            z-index: 2;
            /* Ensure the spinner is above the map */
        }

        /* The spinner that runs while API call resolves. */
        /* Starts as a square with one side that is blue... */
        .spinner {
            width: 200px;
            height: 200px;
            border: 16px solid #f3f3f3;
            border-top: 16px solid #3498db;
            /* ...then rounded to a circle. */
            border-radius: 50%;
            /* 
            This animation is called spin.
            It runs for 1 sec and loops forever. 
            It starts slowly, speeds up, then slows down at the end.
            */
            animation: spin 1s infinite ease-in-out;
            /* Compare to */
            /* animation: spin 2s infinite linear; */

        }

        /* Style for the custom layers control container */
        .custom-layers-control {
            background-color: #d7d286;
            /* Light gray background */
            color: #333;
            /* Dark text color */
            padding: 10px;
            border-radius: 5px;
            text-align: left;
        }



        /* Additional styles for layer labels */
        .custom-layers-control .leaflet-control-layers-label {
            font-weight: bold;
            color: #555;
            /* Medium dark text color */
        }

        .custom-icon img {
            filter: brightness(0) invert(1) hue-rotate(80deg) saturate(7);
            /* Mustard yellow */
        }

        h3.mb-0 {
            font-size: 40px;
        }

        /* The animation that defines the type motion. */
        @keyframes spin {

            /* At the beginning of the animation it isn't rotated. */
            0% {
                transform: rotate(0deg);
            }

            /* At the end of the animation it will rotate a full circle. */
            100% {
                transform: rotate(360deg);
            }
        }


        @media (min-width: 768px) {}
    </style>

</head>

<body class="text-center">
    <div class="cover-container d-flex w-100 h-100 p-3 mx-auto flex-column">
        <header class="d-flex justify-content-between align-items-center py-3 mb-4">
            <!-- Title -->
            <h3 class="mb-0">the atlanta mobility project</h3>

            <!-- Navigation Pills -->
            <ul class="nav nav-pills mb-0">
                <li class="nav-item">
                    <a class="nav-link" href="index.html" id="home-link">home</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="about.html" id="about-link">about</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="author.html" id="author-link">author</a>
                </li>
            </ul>
        </header>
        <!-- Main Content -->
        <main role="main" class="inner cover">
            <p class="lead">This project seeks to understand racialized mobility differentials (inequities in movement
                or capacity for movement) in Atlanta, Georgia.
                Experiences and strategies of mobility are documented through participatory sketch mapping of
                research participants' daily routes, emotions, and experiences produced during as they move.
            </p>

            <p class="lead">
                In context with Atlanta's deeply conflicted history of development, racialized mobility differentials
                and experiences of movement across segregated space and racialized
                infrastructure will be put into analytical conversation through geospatial visualization.</p>

            <a href="#" id="fullscreen-btn" class="btn btn-lg btn-secondary">explore map</a>

            <audio id="background-music" src="mixkit-urban-ambient-sound-2465.mp3" loop></audio>



            <!-- Map & Side Pane -->
            <div class="container-fluid">
                <!-- Side Pane -->
                <div id="side-pane">
                    <h2>Select a story</h2>

                    <!-- Button Row -->
                    <div id="button-row">
                        <button id="btn-1" class="icon-btn">
                            <img src="participantIcons/black_fem.png" alt="Icon 1"> <!-- Replace with your icon -->
                        </button>
                        <button id="btn-2" class="icon-btn">
                            <img src="participantIcons/white_fem.png" alt="Icon 2"> <!-- Replace with your icon -->
                        </button>
                        <button id="btn-3" class="icon-btn">
                            <img src="participantIcons/black_male.png" alt="Icon 3"> <!-- Replace with your icon -->
                        </button>
                        <button id="btn-4" class="icon-btn">
                            <img src="participantIcons/white_nb.png" alt="Icon 4"> <!-- Replace with your icon -->
                        </button>
                        <button id="btn-5" class="icon-btn">
                            <img src="participantIcons/black_fem_m.png" alt="Icon 5"> <!-- Replace with your icon -->
                        </button>
                    </div>

                    <!-- Content Divs -->
                    <div id="content-1" class="content-div">
                        <h3>Debra's Story</h3>
                        <p>This is the content for Button 1.</p>
                    </div>
                    <div id="content-2" class="content-div" style="display: none;">
                        <h3>Emily's Story</h3>
                        <p>This is the content for Button 2.</p>
                    </div>
                    <div id="content-3" class="content-div" style="display: none;">
                        <h3>Bert's Story</h3>
                        <p>This is the content for Button 3.</p>
                    </div>
                    <div id="content-4" class="content-div" style="display: none;">
                        <h3>Jesse's Story</h3>
                        <p>This is the content for Button 4.</p>
                    </div>
                    <div id="content-5" class="content-div" style="display: none;">
                        <h3>Eshe's Story</h3>
                        <p>This is the content for Button 5.</p>
                    </div>

                    <!-- Existing Content -->
                    <div id="layer-controls">
                        <select id="mode-select">
                            <option value="all">Select Experience</option>
                            <option value="driving">Driving</option>
                            <option value="walking">Walking</option>
                            <option value="MARTA">MARTA</option>
                        </select>
                    </div>
                    <div id="additional-text">
                        <p>Select a person to view their experience.</p>
                    </div>
                    <div id="layer-controls">
                        <p class="lead">
                            <a href="index.html" id="fullscreen-btn" class="btn btn-lg btn-secondary">Return to
                                Homepage</a>
                        </p>
                    </div>
                </div>

                <!-- Map Container -->
                <div id="map"></div>
            </div>
            <!-- Footer -->
            <footer class="mastfoot mt-auto">

                <p>Map created by Laurel Sparks | Published May, 2025 | <a href="about.html#data">metadata</a>
                </p>


            </footer>
        </main>
    </div>

    <!-- Add Bootstrap -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz"
        crossorigin="anonymous"></script>
    <!-- Leaflet JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
    <!-- Leaflet Routing Machine JS -->
    <script src="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.js"></script>

    <script type="module">
        import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";
        // Add footer date

        // basically recreating URL with variables
        const a = {
            data: {},
            domain: {
                unit: "block%20group",
                state: ['13'], // ["*"], 
                county: ['089', '121'],
                tract: ["*"],
                block_group: ["*"],
                data: "2019/acs/acs5",
            },
            variables: [{
                name: "totalPopulation",
                label: "Total Population",
                var: "B02001_001E",
            },
            {
                name: "blackPopulation",
                label: "Black Population",
                var: "B02001_003E",
            },

            ],
            vars: {
                totalV: "totalPopulation",
                blackV: "blackPopulation"
            },
            geojson: {
                counties: "data/fultonDekalbBG.json",
            },
        };
        // Set global variables for header, map container, and footer
        const header = document.querySelector("header");
        const mapContainer = document.querySelector("#map");
        const footer = document.querySelector("footer");
        const locate = document.querySelector("#geolocate-ui");

        // Call the main functions to test local storage and setup the map
        testLocalStorage()

        // Check for localStorage
        function testLocalStorage() {
            // try to write and remove an item
            try {
                localStorage.setItem('test', 'test');
                localStorage.removeItem('test');
                console.log(localStorage);
                setLocalStorage()
            } catch (e) {
                console.log('Local storage not available:', e);
                // Will need to fork the code to handle this case :(
            }
        }

        // Check for localStorage and set up caching
        function setLocalStorage() {
            // If our app data is not in localStorage, clear local storage.
            // This is a way to clear out old data while we develop the app.
            if (!localStorage.getItem("myApp")) {
                localStorage.clear();
            } else {
                // If we do have the app data, check if it is expired.
                // If it's older than 6 minutes, clear it.
                const myApp = JSON.parse(localStorage.getItem("myApp"));
                if (checkExpired(myApp.timestamp, 0.1)) {
                    localStorage.clear();
                }
            }
            // Create an object to store in localStorage.
            const data = {
                info: "Storing information in localStorage",
            }
            // Store the data in localStorage, which will add a timestamp.
            try {
                storeData("myApp", data);
            } catch (e) {
                console.warn('Failed to setup storage:', e);
                // Hmm... what to do here?
            }
        }

        // Check for expiration of data in localStorage
        // using timestamp od stored data and desired duration in hours
        function checkExpired(timestamp, hours) {
            const duration = hours * (60 * 60 * 1000); // set duration in hours
            // Milliseconds since 1970 (when rock n roll really started)
            const now = Date.now();
            // Check if data is older than duration
            if (now - timestamp > duration) {
                return true; // Data is expired
            } else {
                return false; // Data is still fresh
            }
        }
        // Retrieve data from localStorage using key and check for expiration
        function retrieveData(key) {
            const cached = localStorage.getItem(key);
            // If no data, return null. End function.
            if (!cached) return null;

            // Destructure properties to new variables
            const { timestamp, data } = JSON.parse(cached);

            // Check if data is expired, e.g., older than 6 minutes
            if (checkExpired(timestamp, 0.1)) {
                // Remove expired data from localStorage
                // which will force a refetch next time.
                localStorage.removeItem(key);
            }
            // Return the data to where function is called
            return data;
        }
        // Store data in localStorage with key name
        function storeData(key, data) {
            // Build an object with timestamp and data
            const cacheObject = {
                timestamp: Date.now(),
                data: data
            };
            // Store the object in localStorage with try/catch
            try {
                localStorage.setItem(key, JSON.stringify(cacheObject));
            } catch (e) {
                console.warn('Failed to cache data:', e);
                // Hmm... what to do here?
                // Over time, localStorage can fill up.
                // Maybe clear and refetch?
            }
        }
        // Fetch GeoJSON data with caching
        // using a key and URL
        async function fetchJSON(key, url) {
            // try/catch block to handle errors
            try {
                // Check cache first
                const cachedData = retrieveData(key);
                // If cachedData not null...
                if (cachedData) {
                    console.log('Using cached data');
                    return cachedData;
                }
                // Fetch fresh data if no cache
                console.log('Fetching fresh data');
                // await for fetch to resolve and parse JSON
                const response = await fetch(url);
                if (!response.ok) throw new Error('Network response was not ok, dig?');
                const data = await response.json();

                // Store the data in localStorage
                storeData(key, data);

                // Return the data to where function is called
                return data;
            } catch (error) {
                console.error('Error fetching data:', error);
                // Hmm... what to do here?
                throw error;
            }
        }

        async function getLocalData() {
            try {
                const zcta = await d3.json("data/fdZCTA.geojson");
                const points = await d3.json("data/allMerged.geojson");
                const homeLoc = await d3.json("data/dislocated_HLs.geojson");
                const places = await d3.json("data/gaPlaces.geojson");
                const roads = await d3.json("data/atlRoadsHoe.geojson");

                //let atl = places.features.filter(feature => feature.properties.NAME === "Atlanta");
                //const atl = await d3.json("data/atlHoe.geojson"); //ensuring no bad formatting

                // console.log('Fetched Data:', { zcta, homeLoc, points, places });
                return { zcta, homeLoc, points, places, roads };
            } catch (error) {
                console.error("ERROR!", error);
                return null;
            }
        }

        // Use async function to setup the map and fetch initial data
        async function setupMap(zcta, homeLoc, points, places) { //need to pass local variable to drawMap()

            let options = {
                center: [33.748997, -84.387985],
                zoom: 13,
                scrollWheelZoom: false
            };

            // Check for cached map options
            if (retrieveData('mapOptions')) {
                console.log('Using cached map options');
                options = retrieveData('mapOptions');
            }

            // Create the map with options
            const map = L.map('map').setView(options.center, options.zoom);
            // Create CartoDB basemap and add to map after data loads

            var Esri_WorldTerrain = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Terrain_Base/MapServer/tile/{z}/{y}/{x}', {
                attribution: 'Tiles &copy; Esri &mdash; Source: USGS, Esri, TANA, DeLorme, and NPS',
                maxZoom: 13
            });
            Esri_WorldTerrain.addTo(map);

            // Store map options in localStorage when map pans or zooms
            map.on('moveend', function () {
                const data = {
                    center: map.getCenter(),
                    zoom: map.getZoom()
                };
                storeData('mapOptions', data);
            });

            return map;

            // Remove the spinner.
            document.querySelector("#loading").remove();

        }

        // Define the function to get the census data.
        async function getCensus() {
            // Create an empty GeoJSON to hold the features
            const acsData = {
                "type": "FeatureCollection",
                "name": "Urban Atlanta Counties",
                "crs": { "type": "name", "properties": { "name": "urn:ogc:def:crs:OGC:1.3:CRS84" } },
                "features": []
            };
            // map method returns new array of variables
            // by looping through a.variables array and returning the var property.
            // join method convert the array into a string with items separated by commas.
            const variables = a.variables.map((v) => v.var).join(",");
            // Create the URL for the Census API.
            const url = `https://api.census.gov/data/${a.domain.data}?get=NAME,${variables}&for=${a.domain.unit}:*&in=state:${a.domain.state}&in=county:${a.domain.county}&in=tract:${a.domain.tract}`;
            const urlDekalb = `https://api.census.gov/data/${a.domain.data}?get=NAME,${variables}&for=${a.domain.unit}:*&in=state:${a.domain.state}`;
            //console.log(url); //looks good

            // Create an array of promises from two fetch requests.
            // The first fetch request gets the census data and assigns it to the variable censusResponse.
            // The second fetch request gets the county geometry data and assigns it to the variable geometryResponse.
            const [censusResponse, geometryResponse] = await Promise.all([
                fetch(url).then((r) => r.json()),
                fetch(a.geojson.counties).then((r) => r.json()),
            ]);
            // The function will pause here until all promises are resolved.

            // Make shorthand variable names.
            // Remove header row (index value 0) from the census data (an array of arrays).
            // slice method starts at second item and selects to the end of the array.
            const censusData = censusResponse.slice(1);
            const countyGeom = geometryResponse;

            //console.log(countyGeom); //TRACTCE: 010304 & GEOID: 131210103041...no ready join field
            //need to create join field 
            countyGeom.features.forEach((feature) => {

                feature.properties.joinField = feature.properties.TRACTCE + feature.properties.BLKGRPCE;
            });

            console.log('newcolumn', countyGeom);

            // Loop through the census data.
            for (const census of censusData) {
                // Slice off last two elements, concatenate, and assign to countyFips.
                // The -2 index is the second to last element in the array.
                const countyFips = census.slice(-2).join("");
                //console.log(countyFips); //7 (tract and block)

                // Find the geometry that matches the countyFips via GEOID.
                // find method returns the first element in array that matches the condition
                // and returns the entire object.
                const match = countyGeom.features.find(g => g.properties.joinField === countyFips);

                // If there is a match, add the census data to it. 
                if (match) {
                    //console.log(match); //looks good
                    // Create a new object in the properties object of the match object.
                    match.properties.census = {};

                    // Loop through the a.variables array.
                    // Use the name property and index to assign the census data.
                    // Builds an object with the name property as the key and the census data as the value.
                    a.variables.forEach(({ name }, i) => {
                        // console.log(name, i, census[i], census[i + 1]);
                        // Offset by 1 because the first element is the county name.
                        match.properties.census[name] = census[i + 1];
                    });

                    // Add the match object to the acsData object.
                    // This will contain all counties with census data.
                    acsData.features.push(match);
                }
            }
            console.log('json', acsData);
            return acsData;
        }// end getCensus

        //promise chaining both async functions
        getLocalData().then((dataUpload) => {
            if (!dataUpload) {
                console.error("Failed to load local data. Check file paths or JSON syntax.");
                return;
            }

            const { zcta, homeLoc, points, places, roads } = dataUpload;

            setupMap(zcta, homeLoc, points, places, roads).then((map) => {
                // Call getCensus() and wait for it to resolve
                getCensus().then((acsData) => {
                    // Now that getCensus has finished, proceed with drawing the map
                    drawMap(zcta, homeLoc, points, places, roads, map, acsData);
                }).catch(error => {
                    console.error("Failed to fetch census data:", error);
                });
            }).catch(error => {
                console.error("Failed to set up the map:", error);
            });
        });
        function highlightRoutes(points, map, participantId = null) {
            if (!points || !points.features) { // Check if points data is valid
                console.error("Invalid points data:", points);
                return;
            }

            if (!map) { // Check if map instance is valid
                console.error("Map instance is not defined.");
                return;
            }

            // Clear existing routes
            clearHighlightedRoutes(map);

            // Group points by layer (participant ID)
            const groupedPoints = points.features.reduce((acc, feature) => {
                if (!feature.properties) {
                    console.error("Feature missing properties:", feature);
                    return acc;
                }

                const layer = feature.properties.layer; // Participant ID
                if (!layer) {
                    console.error("Feature missing layer:", feature);
                    return acc;
                }

                if (!acc[layer]) {
                    acc[layer] = [];
                }
                acc[layer].push(L.latLng(feature.geometry.coordinates[1], feature.geometry.coordinates[0]));
                return acc;
            }, {});

            // Function to create a route for a group of points
            function createRoute(waypoints, mode, isHighlighted) {
                const profile = mode === 'driving' ? 'driving' : mode === 'walking' ? 'walking' : 'cycling'; // Adjust based on your modes
                try {
                    return L.Routing.control({
                        waypoints: waypoints,
                        routeWhileDragging: false,
                        router: L.Routing.osrmv1({
                            serviceUrl: 'https://router.project-osrm.org/route/v1',
                            profile: profile
                        }),
                        lineOptions: {
                            styles: [{
                                color: isHighlighted ? 'red' : mode === 'Driving' ? 'blue' : mode === 'Walking' ? 'green' : 'yellow',
                                opacity: isHighlighted ? 1 : 0.7,
                                weight: isHighlighted ? 7 : 5
                            }]
                        },
                        addWaypoints: false,
                        draggableWaypoints: false,
                        show: false // Hide the default routing control UI
                    });
                } catch (error) {
                    console.error("Error creating route:", error);
                    return null;
                }
            }

            // Create routes for each group
            Object.keys(groupedPoints).forEach(layer => {
                const waypoints = groupedPoints[layer];
                console.log("Waypoints:", waypoints); // Debugging

                if (!waypoints || waypoints.length < 2) {
                    console.error("Invalid waypoints:", waypoints);
                    return;
                }

                const feature = points.features.find(feature => feature.properties.layer === layer); // Use 'layer' instead of 'groupId'
                if (!feature || !feature.properties) {
                    console.error("Feature not found or missing properties for layer:", layer);
                    return;
                }

                const mode = feature.properties.mode;
                if (!mode) {
                    console.error("Feature missing mode for layer:", layer);
                    return;
                }

                // Check if the current layer matches the participant ID to be highlighted
                const isHighlighted = layer === participantId;

                const route = createRoute(waypoints, mode, isHighlighted);

                if (!route) {
                    console.error("Failed to create route for layer:", layer);
                    return;
                }

                // Listen for the 'routesfound' event to access the route geometry
                route.on('routesfound', function (e) {
                    const routes = e.routes;
                    if (routes && routes.length > 0) {
                        const routeGeometry = routes[0].coordinates; // Get the route coordinates

                        // Draw the route as a polyline without markers
                        const routeLine = L.polyline(routeGeometry, {
                            color: isHighlighted ? 'red' : mode === 'Driving' ? 'blue' : mode === 'Walking' ? 'green' : 'orange',
                            weight: isHighlighted ? 7 : 5,
                            opacity: isHighlighted ? 1 : 0.7
                        }).addTo(map); // Add the route line to the map

                        console.log("Route geometry:", routeGeometry); // Debugging
                    }
                });

                // Calculate the route (this triggers the 'routesfound' event)
                route.route();
            });
        }

        // Display GeoJSON
        function drawMap(zcta, homeLoc, points, places, roads, map, acsData) {
            // Create routes using the points data
            highlightRoutes(points, map);

            // Create custom panes with specific zIndex values
            map.createPane('suburbsPane');
            map.getPane('suburbsPane').style.zIndex = 200; // Lowest zIndex

            map.createPane('roadsPane');
            map.getPane('roadsPane').style.zIndex = 300;

            map.createPane('demographicsPane');
            map.getPane('demographicsPane').style.zIndex = 200;

            map.createPane('atlantaPane');
            map.getPane('atlantaPane').style.zIndex = 400;

            map.createPane('homesPane');
            map.getPane('homesPane').style.zIndex = 500;

            map.createPane('pointsPane');
            map.getPane('pointsPane').style.zIndex = 600; // Highest zIndex

            //census data first
            const color = d3.scaleQuantile()
                .domain([0.0, 1.0])
                .range(["#f9f6f6", "#cfb0b0", "#4f3030", "#170909"]);
            color.domain(acsData.features.map((d) => {
                return (d.properties.census[a.vars.blackV] / d.properties.census[a.vars.totalV]);
            }
            ));

            const demographics = L.geoJson(acsData, {
                pane: 'demographicsPane', // Assign to demographicsPane
                style: function (feature) {
                    const rate = (feature.properties.census[a.vars.blackV] / feature.properties.census[a.vars.totalV]);
                    return {
                        fillColor: color(rate),
                        weight: 0.25,
                        opacity: 1,
                        color: color(rate),
                        fillOpacity: 1,
                    };
                },
                onEachFeature: function (feature, layer) {
                    layer.bindTooltip(
                        `Community: ${feature.properties.TRACTCE}-${feature.properties.BLKGRPCE}: <br>
black pop: ~ ${(
                            (feature.properties.census[a.vars.blackV] / feature.properties.census[a.vars.totalV]) *
                            100
                        ).toFixed(1)}% <br>
white pop: ~ ${(
                            (1 - feature.properties.census[a.vars.blackV] / feature.properties.census[a.vars.totalV]) *
                            100
                        ).toFixed(1)}%`
                    );
                },
            }).addTo(map);

            // Define the SVG icon for home location
            const iconUrl = "mapbox-maki-8.2.0-0-g6ab50f3/mapbox-maki-6ab50f3/icons/home.svg";
            const svgIcon = L.divIcon({
                html: `<img src="${iconUrl}" alt="Home Icon" width="32" height="32" />`, // Use an <img> tag to load the external SVG
                iconSize: [32, 32],
                iconAnchor: [16, 32],
                popupAnchor: [0, -32],
                className: 'custom-icon' // Apply the CSS class
            });

            // Create a Leaflet GeoJSON layer with style and popup
            const homes = L.geoJSON(homeLoc, { //change symbol
                pointToLayer: (feature, latlng) => {
                    return L.marker(latlng, {
                        icon: svgIcon
                    });
                },
                onEachFeature: (feature, layer) => {
                    if (feature.properties) {
                        const alias = (feature.properties.aliasName);
                        layer.bindPopup(
                            `<h3>${alias}'s neighborhood</h3>
`
                        );
                    }
                }
            }).addTo(map);

            // Define a color scale for the points
            const pointsScale = d3.scaleOrdinal()
                .domain(['Home Location', 'Grocery', 'Recreation', 'Workplace', 'Family', 'Religious', 'Education', 'Social', 'School',
                    'Enjoyment', 'Family', 'Health', 'Community Engagement'])
                .range(d3.schemeTableau10);

            // Empty layer group for buffers
            const bufferLayer = L.layerGroup().addTo(map);

            // Dictionary to store buffers by mode
            const buffersByMode = {
                driving: [],
                walking: [],
                MARTA: []
            };
            const pointsLayer = L.geoJSON(points, {
                pane: 'pointsPane', // Assign to pointsPane
                pointToLayer: (feature, latlng) => {
                    let pointColor = pointsScale(feature.properties.description);
                    // Default style for the marker
                    let markers = {
                        radius: 5,
                        fillColor: pointColor,
                        color: pointColor,
                        weight: 0.5,
                        fillOpacity: 1
                    };

                    let bufferRadius = 1; // Default buffer size
                    let bufferColor = "red";
                    let mode = "";

                    // Set buffer size and marker style based on feature properties
                    if (feature.properties) {
                        const { description, mode: featureMode } = feature.properties;
                        console.log("Mode:", featureMode, "Buffer Radius:", bufferRadius);

                        if (description === "Home Location") {
                            markers.fillOpacity = 0; // Hide Home Location
                            markers.radius = 0;
                            bufferRadius = 0;
                        } else if (description !== "Home Location") {
                            markers.fillColor = pointColor;
                            markers.radius = 2;
                            markers.fillOpacity = 1;

                            if (featureMode === "driving") {
                                bufferRadius = 8046.72; // 7.5 miles in meters
                                bufferColor = "#640112";
                                mode = "driving";
                            } else if (featureMode === "walking") {
                                bufferRadius = 400; // 400m is standard walking distance in planning (1/4 mile)
                                bufferColor = "#FF7F00";
                                mode = "walking";
                            } else if (featureMode === "MARTA") {
                                bufferRadius = 800; // People are willing to walk longer for faster transit. Doubles the walking standard.
                                bufferColor = "#C83E00";
                                mode = "MARTA";
                            } else {
                                bufferRadius = 0;
                            }
                        }
                    }
                    // Create the circle marker for the point
                    const marker = L.circleMarker(latlng, markers);
                    // Create the buffer circle around the marker if necessary
                    if (bufferRadius > 0 && mode) {
                        const buffer = L.circle(latlng, {
                            radius: bufferRadius,
                            color: bufferColor,
                            fillColor: bufferColor,
                            fillOpacity: 0.1, // Increased opacity to make buffer more visible
                            weight: 1
                        });
                        // Store the buffer in the dictionary by mode
                        buffersByMode[mode].push(buffer);
                        marker.buffer = buffer;
                    }

                    return marker; // Return the marker to be added to the points layer
                },

                // Adding popups
                onEachFeature: (feature, layer) => {
                    if (feature.properties) {
                        const { description, mode } = feature.properties;
                        layer.bindPopup(
                            `<h3>Participant: ${description}</h3>
<p>Mode of Transport: ${mode}</p>`
                        );
                    }
                }
            }).addTo(map);

            // Function to show/hide buffers based on selected mode
            function updateBuffers(selectedMode) {
                // Hide all buffers
                Object.values(buffersByMode).forEach(buffers => {
                    if (buffers) { // Ensure buffers is defined
                        buffers.forEach(buffer => buffer.removeFrom(bufferLayer));
                    }
                });

                // Show buffers for the selected mode
                if (selectedMode === "all") {
                    // Show all buffers
                    Object.values(buffersByMode).forEach(buffers => {
                        if (buffers) { // Ensure buffers is defined
                            buffers.forEach(buffer => buffer.addTo(bufferLayer));
                        }
                    });
                } else {
                    // Show buffers for the selected mode
                    if (buffersByMode[selectedMode]) { // Ensure the mode exists
                        buffersByMode[selectedMode].forEach(buffer => buffer.addTo(bufferLayer));
                    }
                }
            }

            // Add event listener to the dropdown
            const modeSelect = document.getElementById("mode-select");
            modeSelect.addEventListener("change", (event) => {
                const selectedMode = event.target.value;
                updateBuffers(selectedMode);
            });

            // Initialize by showing no buffers
            updateBuffers("none"); // Use a mode that doesn't exist, or skip this line entirely

            const atlhoe = L.geoJSON(places, {
                pane: 'atlantaPane', // Assign to atlantaPane
                onEachFeature: (feature, layer) => {
                    if (feature.properties.NAME === "Atlanta") {
                        layer.setStyle({
                            color: '#efab00',
                            fillOpacity: 0,
                            weight: 4,
                            dashArray: '2,6',
                        });
                    }
                    else {
                        layer.setStyle({
                            fillOpacity: 0,
                            weight: 0,
                            interactive: false
                        });
                    }

                }
            }).addTo(map); //using Leaflet

            const suburbs = L.geoJSON(places, {
                pane: 'suburbsPane', // Assign to suburbsPane
                onEachFeature: (feature, layer) => {
                    layer.setStyle({
                        fillOpacity: 0.9,
                        weight: 0.5,
                        fillColor: '#bdb4b4',
                        color: '#bdb4b4',
                        interactive: false
                    });
                }
            }).addTo(map);

            const roadSys = L.geoJSON(roads, {
                pane: 'roadsPane', // Assign to roadsPane
                onEachFeature: (feature, layer) => {
                    if (feature.properties.MTFCC === "S1100") { // Secondary
                        layer.setStyle({
                            color: '#98191f',
                            weight: 6
                        });
                    } else {
                        layer.setStyle({
                            color: '#efa9ae',
                            weight: 1,
                            interactive: false
                        });
                    }
                }
            }).addTo(map);

            var extraLayers = {

            }
            var participantData = {
                "Participant Locations": pointsLayer,
                "Particpant Neigborhoods": homes,
                "City Outline": atlhoe
            }

            L.Control.Layers.Custom = L.Control.Layers.extend({
                onAdd: function (map) {
                    var container = L.Control.Layers.prototype.onAdd.call(this, map);
                    L.DomUtil.addClass(container, 'custom-layer-control');
                    return container;
                }
            });

            var customLayersControl = new L.Control.Layers.Custom(extraLayers, participantData).addTo(map);
            // Check for locations stored by user in localStorage
            // if locations exist, draw them on the map
            if (retrieveData('locations')) {
                const allLocations = retrieveData('locations')
                console.log(allLocations)
                drawLocations(map, homes, allLocations)
            }
        }

        // Function to switch content
        function switchContent(buttonId, contentId) {
            // Hide all content divs
            document.querySelectorAll('.content-div').forEach(div => {
                div.style.display = 'none';
            });

            // Show the selected content div
            const selectedContent = document.getElementById(contentId);
            if (selectedContent) {
                selectedContent.style.display = 'block';
            }
        }

        function clearHighlightedRoutes(map) {
            map.eachLayer(layer => {
                if (layer instanceof L.Polyline) {
                    map.removeLayer(layer);
                }
            });
        }

        document.getElementById('btn-1').addEventListener('click', function () {
            switchContent('btn-1', 'content-1');
            highlightRoutes(points, map, 'p6'); // Highlight routes for participant 'p1'
        });

        document.getElementById('btn-2').addEventListener('click', function () {
            switchContent('btn-2', 'content-2');
            highlightRoutes(points, map, 'p2'); // Highlight routes for participant 'p2'
        });

        document.getElementById('btn-3').addEventListener('click', function () {
            switchContent('btn-3', 'content-3');
            highlightRoutes(points, map, 'p9'); // Highlight routes for participant 'p1'
        });

        document.getElementById('btn-4').addEventListener('click', function () {
            switchContent('btn-4', 'content-4');
            highlightRoutes(points, map, 'p10'); // Highlight routes for participant 'p2'
        });

        document.getElementById('btn-5').addEventListener('click', function () {
            switchContent('btn-5', 'content-5');
            highlightRoutes(points, map, 'p1'); // Highlight routes for participant 'p2'
        });


        document.getElementById('fullscreen-btn').addEventListener('click', function (event) {
            event.preventDefault();
            const container = document.querySelector('.container-fluid');
            const musicElement = document.getElementById('background-music');

            if (!document.fullscreenElement) {
                // Enter fullscreen
                if (container.requestFullscreen) {
                    container.requestFullscreen();
                } else if (container.mozRequestFullScreen) {
                    container.mozRequestFullScreen();
                } else if (container.webkitRequestFullscreen) {
                    container.webkitRequestFullscreen();
                } else if (container.msRequestFullscreen) {
                    container.msRequestFullscreen();
                }

                // Play music
                if (musicElement) {
                    musicElement.play();
                }
            } else {
                // Exit fullscreen
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }

                // Pause music
                if (musicElement) {
                    musicElement.pause();
                }
            }
        });

        // Get all navigation links
        const navLinks = document.querySelectorAll('.nav-link');

        // Add click event listeners to each link
        navLinks.forEach(link => {
            link.addEventListener('click', function (event) {
                // Prevent default link behavior (optional)
                event.preventDefault();

                // Remove the 'active' class from all links
                navLinks.forEach(link => link.classList.remove('active'));

                // Add the 'active' class to the clicked link
                this.classList.add('active');

                // Optional: Navigate to the link's href
                window.location.href = this.href;
            });
        });
        // Get the current page URL
        const currentPage = window.location.href;

        // Loop through each link and check if it matches the current page
        navLinks.forEach(link => {
            if (link.href === currentPage) {
                link.classList.add('active');
            }
        });

    </script>
</body>

</html>